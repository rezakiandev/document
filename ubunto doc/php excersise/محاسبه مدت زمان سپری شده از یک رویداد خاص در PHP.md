


✅ **هدف:** 
برنامه‌ای که مشخص کند **از یک تاریخ مشخص (مثلاً تاریخ تولد یا یک رویداد خاص)** چند **سال، ماه و روز** گذشته است.

---

## **📌 سودوکد (Pseudo Code)**

1️⃣ دریافت **تاریخ رویداد** از کاربر (یا مقدار از پیش تعیین‌شده).  
2️⃣ دریافت **تاریخ امروز**.  
3️⃣ محاسبه **اختلاف بین دو تاریخ**.  
4️⃣ نمایش نتیجه شامل تعداد **سال‌ها، ماه‌ها و روزها**.

---

## **🔹 کد PHP کامل**

```php
<?php
// 1️⃣ تنظیم منطقه زمانی
date_default_timezone_set("Europe/Madrid");

// 2️⃣ دریافت تاریخ رویداد از کاربر
echo "لطفاً تاریخ رویداد خود را وارد کنید (YYYY-MM-DD): ";
$eventDateInput = trim(fgets(STDIN));

// 3️⃣ بررسی صحت فرمت ورودی
if (!preg_match("/^\d{4}-\d{2}-\d{2}$/", $eventDateInput)) {
    echo "⚠ فرمت تاریخ نامعتبر است. لطفاً تاریخ را به‌صورت YYYY-MM-DD وارد کنید.\n";
    exit;
}

// 4️⃣ ایجاد شیء `DateTime` برای تاریخ رویداد
$eventDate = new DateTime($eventDateInput);

// 5️⃣ دریافت تاریخ امروز
$today = new DateTime();

// 6️⃣ محاسبه اختلاف بین تاریخ رویداد و امروز
$diff = $eventDate->diff($today);

// 7️⃣ نمایش خروجی
echo "⏳ از تاریخ " . $eventDate->format("Y-m-d") . " تا امروز " . 
     $diff->y . " سال، " . $diff->m . " ماه و " . $diff->d . " روز گذشته است.\n";
?>
```

---

## **🔍 توضیح کامل کد و توابع استفاده‌شده**

### **1️⃣ تنظیم منطقه زمانی**

```php
date_default_timezone_set("Europe/Madrid");
```

🔹 **تابع `date_default_timezone_set()`** منطقه زمانی پیش‌فرض را تعیین می‌کند.  
🔹 در اینجا، منطقه زمانی **اروپای مادرید (`Europe/Madrid`)** تنظیم شده است.  
🔹 بدون تنظیم این مقدار، ممکن است تاریخ و زمان نادرست نمایش داده شود.

✅ **مثال:**

```php
date_default_timezone_set("Asia/Tehran");
echo date("Y-m-d H:i:s");
```

✅ **خروجی (مثلاً):**

```
2025-02-27 14:30:00
```

---

### **2️⃣ دریافت تاریخ رویداد از کاربر**

```php
echo "لطفاً تاریخ رویداد خود را وارد کنید (YYYY-MM-DD): ";
$eventDateInput = trim(fgets(STDIN));
```

🔹 `echo "لطفاً تاریخ رویداد خود را وارد کنید: ";` → پیام درخواست مقدار ورودی را نمایش می‌دهد.  
🔹 `fgets(STDIN)` → مقدار ورودی را از کاربر دریافت می‌کند.  
🔹 `trim(fgets(STDIN))` → **`trim()`** فضاهای خالی اضافه (مانند **Enter**) را حذف می‌کند.

✅ **مثال ورودی و مقدار ذخیره‌شده در `$eventDateInput`**

```
لطفاً تاریخ رویداد خود را وارد کنید (YYYY-MM-DD): 2000-07-15
```

🔹 مقدار **`2000-07-15`** درون **`$eventDateInput`** ذخیره می‌شود.

---

### **3️⃣ بررسی صحت فرمت ورودی**

```php
if (!preg_match("/^\d{4}-\d{2}-\d{2}$/", $eventDateInput)) {
    echo "⚠ فرمت تاریخ نامعتبر است. لطفاً تاریخ را به‌صورت YYYY-MM-DD وارد کنید.\n";
    exit;
}
```

🔹 **`preg_match()`** بررسی می‌کند که آیا مقدار ورودی با الگوی `YYYY-MM-DD` مطابقت دارد یا نه.  
🔹 اگر فرمت اشتباه باشد، پیام خطا نمایش داده شده و برنامه متوقف می‌شود.

✅ **ورودی‌های معتبر و نامعتبر:**

```
✅ 2000-07-15  → صحیح
❌ 15/07/2000  → نادرست
❌ 2000-7-5    → نادرست
```

---

### **4️⃣ تبدیل تاریخ ورودی به شیء `DateTime`**

```php
$eventDate = new DateTime($eventDateInput);
```

🔹 **`new DateTime($eventDateInput)`** مقدار ورودی را به یک شیء `DateTime` تبدیل می‌کند.  
🔹 این شیء امکان انجام عملیات تاریخ (مثل مقایسه و اختلاف) را فراهم می‌کند.

✅ **مثال:**

```php
$eventDate = new DateTime("2000-07-15");
echo $eventDate->format("Y-m-d");
```

✅ **خروجی:**

```
2000-07-15
```

---

### **5️⃣ دریافت تاریخ امروز**

```php
$today = new DateTime();
```

🔹 این مقدار تاریخ فعلی سیستم را دریافت می‌کند.

✅ **مثال خروجی:**

```
2025-02-27
```

---

### **6️⃣ محاسبه اختلاف بین تاریخ رویداد و امروز**

```php
$diff = $eventDate->diff($today);
```

🔹 تابع **`diff()`** اختلاف بین دو شیء `DateTime` را محاسبه می‌کند.  
🔹 **خروجی:**

- یک شیء `DateInterval` که شامل تعداد سال‌ها، ماه‌ها و روزهای اختلاف است.

✅ **مثال:**

```php
$date1 = new DateTime("2000-07-15");
$date2 = new DateTime("2025-02-27");
$diff = $date1->diff($date2);
echo $diff->y . " سال، " . $diff->m . " ماه و " . $diff->d . " روز";
```

✅ **خروجی:**

```
24 سال، 7 ماه و 12 روز
```

(یعنی از تاریخ 15 جولای 2000 تا 27 فوریه 2025، **24 سال، 7 ماه و 12 روز** گذشته است.)

---

### **7️⃣ نمایش خروجی**

```php
echo "⏳ از تاریخ " . $eventDate->format("Y-m-d") . " تا امروز " . 
     $diff->y . " سال، " . $diff->m . " ماه و " . $diff->d . " روز گذشته است.\n";
```

🔹 مقدار **`$diff->y`** تعداد **سال‌های گذشته** را نمایش می‌دهد.  
🔹 مقدار **`$diff->m`** تعداد **ماه‌های گذشته** را نمایش می‌دهد.  
🔹 مقدار **`$diff->d`** تعداد **روزهای گذشته** را نمایش می‌دهد.

✅ **نمونه خروجی:**

```
⏳ از تاریخ 2000-07-15 تا امروز 24 سال، 7 ماه و 12 روز گذشته است.
```

---

## **📌 جدول توابع و متدهای استفاده‌شده**

|تابع|توضیح|
|---|---|
|`date_default_timezone_set()`|تنظیم منطقه زمانی برای جلوگیری از مشکلات زمان‌بندی|
|`fgets(STDIN)`|دریافت ورودی از کاربر|
|`trim()`|حذف فضای اضافی از ورودی|
|`preg_match()`|بررسی فرمت تاریخ ورودی با regex|
|`new DateTime()`|ایجاد یک شیء `DateTime` برای کار با تاریخ‌ها|
|`format("Y-m-d")`|نمایش تاریخ در فرمت مشخص|
|`diff($date2)`|محاسبه اختلاف بین دو تاریخ|
|`$diff->y, $diff->m, $diff->d`|دریافت تعداد سال، ماه و روزهای اختلاف|

---

## **📌 مزایای این روش**

✔ **دریافت ورودی پویا** (کاربر می‌تواند هر تاریخی را وارد کند).  
✔ **بررسی اعتبار ورودی** (با استفاده از `preg_match()`).  
✔ **دقیق و سریع** (استفاده از کلاس `DateTime`).  
✔ **کاربردی برای محاسبه‌ی مدت‌زمان سپری‌شده از هر رویدادی** (مثل تولد، ازدواج، پروژه و غیره).

✅ **حالا اگر سوالی داشتی، بپرس! 🚀**


### **✅ خوبی‌های استفاده از `->` در PHP**

🔹 **ساده و خوانا:**

- استفاده از `->` باعث می‌شود که دسترسی به ویژگی‌ها و متدهای یک شیء خواناتر و کوتاه‌تر باشد.
- **مثال خوانا و ساده:**
    
    ```php
    $date = new DateTime();
    echo $date->format("Y-m-d");
    ```
    
    به‌جای استفاده از توابع پراکنده و روش‌های پیچیده.

🔹 **استفاده از شیءگرایی (OOP):**

- PHP یک زبان شیءگراست، و `->` بخشی از قابلیت‌های OOP است که باعث می‌شود کدها مرتب‌تر و قابل‌مدیریت‌تر باشند.

🔹 **انعطاف‌پذیری بالا:**

- اگر از کلاس‌ها و اشیاء استفاده کنی، می‌توانی **متدهای خودت** را بسازی و از `->` برای دسترسی به آن‌ها استفاده کنی.
- **مثال:**
    
    ```php
    class Car {
        public $brand;
        public function __construct($brand) {
            $this->brand = $brand;
        }
        public function getBrand() {
            return "این ماشین برند " . $this->brand . " است.";
        }
    }
    $myCar = new Car("BMW");
    echo $myCar->getBrand();
    ```
    
    ✅ خروجی:
    
    ```
    این ماشین برند BMW است.
    ```
    

🔹 **توسعه‌پذیری و مقیاس‌پذیری:**

- وقتی از `->` استفاده می‌کنی، راحت‌تر می‌توانی سیستم‌های پیچیده‌تر بسازی.
- برنامه‌های بزرگ (مثلاً CMSها مثل وردپرس و لاراول) روی شیءگرایی ساخته شده‌اند، و `->` به آن‌ها قدرت می‌دهد.

🔹 **کاهش احتمال خطا در متغیرهای سراسری (Global Variables):**

- وقتی از OOP و `->` استفاده کنی، نیاز کمتری به متغیرهای سراسری داری و احتمال تداخل و مشکلات کمتری در مدیریت داده‌ها پیش می‌آید.

---

### **❌ بدی‌های استفاده از `->` در PHP**

🔹 **عدم امکان استفاده روی آرایه‌ها و متغیرهای معمولی:**

- فقط روی **اشیاء (Objects)** کار می‌کند و نمی‌توان آن را روی **آرایه‌ها (`array`) یا متغیرهای معمولی** استفاده کرد.
- **مثال نامعتبر:**
    
    ```php
    $arr = ["name" => "Yasaman"];
    echo $arr->name; // ❌ خطا می‌دهد
    ```
    
    ✅ **راه حل:** استفاده از آرایه‌های شیءگرا (`ArrayObject`):
    
    ```php
    $arr = new ArrayObject(["name" => "Yasaman"]);
    echo $arr->name; // ✅ خروجی: Yasaman
    ```
    

🔹 **عملکرد کندتر نسبت به متغیرهای ساده:**

- چون `->` از کلاس‌ها و اشیاء استفاده می‌کند، هر بار که از آن استفاده می‌کنی، PHP باید بررسی کند که آیا متد یا ویژگی موردنظر وجود دارد یا نه.
- در حجم بالا، کمی کندتر از متغیرهای ساده خواهد بود.

🔹 **نیاز به تعریف کلاس و شیء:**

- اگر فقط یک مقدار ساده نیاز داری، **تعریف کلاس ممکن است بیش از حد پیچیده باشد.**
- مثلا، این کار غیرضروری است:
    
    ```php
    class Number {
        public $value;
        public function __construct($val) {
            $this->value = $val;
        }
    }
    $num = new Number(10);
    echo $num->value; // 10
    ```
    
    درحالی‌که خیلی ساده‌تر می‌توانستی این کار را انجام دهی:
    
    ```php
    $num = 10;
    echo $num;
    ```
    

🔹 **خطاهای مربوط به اشیاء تهی (`null`)**

- اگر یک متغیر **شیء نباشد و مقدار `null` داشته باشد**، هنگام استفاده از `->` خطای **`Fatal error`** دریافت خواهی کرد.
- **مثال نامعتبر:**
    
    ```php
    $obj = null;
    echo $obj->name; // ❌ خطا می‌دهد
    ```
    
    ✅ **راه‌حل:** استفاده از **`?->` (Null Safe Operator) در PHP 8**
    
    ```php
    $obj = null;
    echo $obj?->name; // ✅ خطا نمی‌دهد، فقط مقدار null برمی‌گرداند
    ```
    

🔹 **عدم امکان استفاده در توابع ایستا (`Static Methods`):**

- در متدهای ایستا (متدهای `static`)، باید از `::` (دو نقطه) به‌جای `->` استفاده کرد.
- **مثال نامعتبر:**
    
    ```php
    class Math {
        public static function square($num) {
            return $num * $num;
        }
    }
    echo Math->square(4); // ❌ خطا می‌دهد
    ```
    
    ✅ **روش صحیح:**
    
    ```php
    echo Math::square(4); // ✅ خروجی: 16
    ```
    

---

## **📌 خلاصه‌ی خوبی‌ها و بدی‌ها**

|**ویژگی**|**خوبی‌ها**|**بدی‌ها**|
|---|---|---|
|**خوانایی و سادگی**|✅ کدها خواناتر و مرتب‌تر می‌شوند|❌ نیاز به تعریف کلاس دارد|
|**شیءگرایی و توسعه‌پذیری**|✅ مناسب برای پروژه‌های بزرگ و OOP|❌ استفاده‌ی نادرست باعث پیچیدگی غیرضروری می‌شود|
|**انعطاف‌پذیری بالا**|✅ امکان استفاده در کلاس‌ها و توابع متنوع|❌ در توابع `static` باید از `::` استفاده شود|
|**مدیریت بهتر داده‌ها**|✅ کاهش نیاز به متغیرهای سراسری (Global)|❌ سرعت کمتر نسبت به متغیرهای ساده|
|**امکان استفاده در OOP Frameworks**|✅ در Laravel, WordPress, Symfony استفاده می‌شود|❌ فقط برای اشیاء قابل استفاده است (نه آرایه‌ها)|
|**مدیریت حافظه و کارایی**|✅ مناسب برای مدیریت پیچیده داده‌ها|❌ در پردازش‌های سنگین کمی کندتر است|

---

## **📌 نتیجه‌گیری**

✔ **اگر پروژه‌ی تو شیءگرا (OOP) است، `->` بسیار مفید خواهد بود.**  
✔ **برای پروژه‌های بزرگ (مثلاً Laravel) استفاده از `->` استاندارد است.**  
✔ **اگر فقط یک مقدار ساده نیاز داری، نیازی به `->` و کلاس نداری!**  
✔ **در `null` دقت کن و از `?->` در PHP 8+ استفاده کن.**  
✔ **اگر متد `static` داری، از `::` به‌جای `->` استفاده کن.**

✅ **حالا اگر سوالی داشتی، بپرس! 🚀🔥**


### **📌 متد `preg_match()` در PHP - توضیح کامل**

✅ **هدف:**  
`preg_match()` یک تابع در PHP است که **عبارت منظم (Regular Expression - Regex)** را درون یک رشته بررسی می‌کند و اگر مطابقتی پیدا کند، مقدار `1` برمی‌گرداند، در غیر این صورت مقدار `0` را برمی‌گرداند.

---

## **📌 سینتکس (ساختار کلی)**

```php
preg_match( $pattern, $subject, &$matches, $flags, $offset );
```

🔹 **`$pattern`** → الگوی جستجو (Regular Expression).  
🔹 **`$subject`** → رشته‌ای که می‌خواهیم در آن جستجو کنیم.  
🔹 **`$matches` (اختیاری)** → آرایه‌ای که مقادیر پیدا شده را در خود ذخیره می‌کند.  
🔹 **`$flags` (اختیاری)** → تنظیمات اضافی.  
🔹 **`$offset` (اختیاری)** → محل شروع جستجو در رشته.

✅ **خروجی:**

- **`1`** اگر تطابق پیدا شد.
- **`0`** اگر تطابق پیدا نشد.
- **`false`** در صورت وجود خطا.

---

## **📌 مثال ساده: بررسی فرمت ایمیل**

```php
<?php
$email = "test@example.com";
$pattern = "/^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/";

if (preg_match($pattern, $email)) {
    echo "✅ ایمیل معتبر است.";
} else {
    echo "❌ ایمیل نامعتبر است.";
}
?>
```

✅ **خروجی:**

```
✅ ایمیل معتبر است.
```

📌 **چرا این الگو کار می‌کند؟**

- **`^`** → نشان می‌دهد که الگو باید از ابتدای رشته باشد.
- **`[a-zA-Z0-9._%+-]+`** → شامل حروف، اعداد و برخی کاراکترهای خاص قبل از `@`.
- **`@`** → علامت `@` باید در ایمیل وجود داشته باشد.
- **`[a-zA-Z0-9.-]+`** → نام دامنه (مثلاً `example`).
- **`\.`** → نقطه بین دامنه و پسوند (`.`).
- **`[a-zA-Z]{2,}`** → پسوند دامنه باید حداقل دو حرف باشد (`com`, `org`, `net`, ...).

---

## **📌 بررسی کد ملی ایران**

```php
<?php
$nationalCode = "1234567891";
$pattern = "/^\d{10}$/";

if (preg_match($pattern, $nationalCode)) {
    echo "✅ کد ملی معتبر است.";
} else {
    echo "❌ کد ملی نامعتبر است.";
}
?>
```

✅ **خروجی:**

```
✅ کد ملی معتبر است.
```

📌 **توضیح الگو `^\d{10}$`**

- **`^`** → شروع رشته.
- **`\d{10}`** → ده رقم عدد (`\d` یعنی digit).
- **`$`** → انتهای رشته.

---

## **📌 استفاده از `preg_match()` برای ذخیره مقدار پیدا شده**

🔹 `preg_match()` می‌تواند مقدار **تطابق‌یافته را درون یک آرایه ذخیره کند**.

```php
<?php
$text = "امروز 27 فوریه 2025 است.";
$pattern = "/(\d{2}) فوریه (\d{4})/";
preg_match($pattern, $text, $matches);

print_r($matches);
?>
```

✅ **خروجی:**

```
Array
(
    [0] => 27 فوریه 2025
    [1] => 27
    [2] => 2025
)
```

📌 **چرا این اتفاق افتاد؟**

- `(\d{2})` → بخش اول `27` را ذخیره کرد (`$matches[1]`).
- `(\d{4})` → بخش دوم `2025` را ذخیره کرد (`$matches[2]`).
- **`$matches[0]` همیشه کل مقدار تطبیق‌یافته را نگه می‌دارد.**

---

## **📌 مقایسه `preg_match()` با `preg_match_all()`**

🔹 `preg_match()` **فقط اولین تطابق را پیدا می‌کند**.  
🔹 `preg_match_all()` **همه‌ی تطابق‌های ممکن را پیدا و ذخیره می‌کند**.

✅ **مثال: پیدا کردن همه‌ی اعداد در یک رشته**

```php
<?php
$text = "امروز 27 فوریه 2025 است و فردا 28 فوریه 2025.";
$pattern = "/\d+/";
preg_match_all($pattern, $text, $matches);

print_r($matches);
?>
```

✅ **خروجی:**

```
Array
(
    [0] => Array
        (
            [0] => 27
            [1] => 2025
            [2] => 28
            [3] => 2025
        )
)
```

📌 **چرا `preg_match_all()` مفید است؟**

- چون تمام **اعداد موجود در متن** (`27`, `2025`, `28`, `2025`) را پیدا کرده است.
- **`preg_match()` فقط `27` را پیدا می‌کرد!**

---

## **📌 `preg_match()` با `flags` و `offset`**

🔹 **`flags`**: می‌توان به آن دستورات خاصی اضافه کرد.  
🔹 **`offset`**: مشخص می‌کند جستجو از کدام بخش رشته شروع شود.

✅ **مثال: جستجو از موقعیت خاصی در متن**

```php
<?php
$text = "امروز 27 فوریه 2025 است و فردا 28 فوریه 2025.";
$pattern = "/\d+/";
preg_match($pattern, $text, $matches, 0, 10);

print_r($matches);
?>
```

✅ **خروجی:**

```
Array
(
    [0] => 2025
)
```

📌 **چرا `2025` را پیدا کرد؟**

- چون `offset = 10` است و جستجو از حرف **دهم به بعد** انجام شده است، پس `27` را نادیده گرفته و `2025` را پیدا کرده است.

---

## **📌 مزایای `preg_match()`**

✔ **دقیق و سریع:** می‌تواند الگوهای پیچیده را خیلی سریع تشخیص دهد.  
✔ **کاربرد گسترده:** برای اعتبارسنجی ایمیل، کد ملی، شماره موبایل، استخراج داده و ...  
✔ **قابلیت ذخیره‌ی تطابق‌ها:** می‌توان مقدار پیدا شده را در آرایه `$matches` ذخیره کرد.  
✔ **انعطاف‌پذیری بالا:** می‌توان با `flags` و `offset` جستجو را سفارشی کرد.

---

## **📌 معایب `preg_match()`**

❌ **پیچیدگی در نوشتن الگوهای Regex:**

- بعضی از الگوها پیچیده می‌شوند و نیاز به تجربه دارند.  
    ❌ **پردازش سنگین برای داده‌های بزرگ:**
- اگر روی یک فایل متنی بزرگ اجرا شود، سرعت پردازش کاهش می‌یابد.  
    ❌ **عدم تطبیق چندگانه (`preg_match` فقط اولین مورد را پیدا می‌کند):**
- اگر به چند مورد نیاز داری، باید از `preg_match_all()` استفاده کنی.

---

## **📌 نتیجه‌گیری**

- `preg_match()` برای **جستجوی یک الگوی خاص در یک متن** استفاده می‌شود.
- می‌تواند **درستی داده‌ها را بررسی کند** (مثلاً ایمیل، شماره تلفن، کد ملی).
- **برای یافتن همه‌ی موارد موجود در متن، از `preg_match_all()` استفاده کن.**
- در **متون طولانی، `offset`** به بهینه‌سازی کمک می‌کند.

✅ **اگر سوالی داشتی، بپرس! 🚀**

### **🚀 بازنویسی کد بدون استفاده از `->` و `preg_match`**

✅ **تغییرات اصلی:**

1. **به‌جای `DateTime` از `strtotime()` و `time()` استفاده شده است.**
2. **به‌جای `preg_match()` از `substr()` و `explode()` برای بررسی فرمت تاریخ استفاده شده است.**
3. **تاریخ رویداد و تاریخ امروز را به ثانیه تبدیل کرده و اختلاف آن‌ها را محاسبه می‌کنیم.**

---

## **📌 کد بازنویسی شده بدون `->` و `preg_match()`**

```php
<?php
// 1️⃣ تنظیم منطقه زمانی
date_default_timezone_set("Europe/Madrid");

// 2️⃣ دریافت تاریخ رویداد از کاربر
echo "لطفاً تاریخ رویداد خود را وارد کنید (YYYY-MM-DD): ";
$eventDateInput = trim(fgets(STDIN));

// 3️⃣ بررسی فرمت تاریخ (بدون `preg_match`)
$parts = explode("-", $eventDateInput);
if (count($parts) != 3 || strlen($parts[0]) != 4 || strlen($parts[1]) != 2 || strlen($parts[2]) != 2) {
    echo "⚠ فرمت تاریخ نامعتبر است. لطفاً تاریخ را به‌صورت YYYY-MM-DD وارد کنید.\n";
    exit;
}

// 4️⃣ تبدیل تاریخ رویداد و تاریخ امروز به `timestamp`
$eventTimestamp = strtotime($eventDateInput);
$todayTimestamp = time();

// 5️⃣ محاسبه تعداد ثانیه‌های اختلاف
$diffSeconds = abs($todayTimestamp - $eventTimestamp);

// 6️⃣ تبدیل اختلاف ثانیه به سال، ماه و روز
$years = floor($diffSeconds / (365 * 24 * 60 * 60));
$remainingSeconds = $diffSeconds % (365 * 24 * 60 * 60);
$months = floor($remainingSeconds / (30 * 24 * 60 * 60));
$remainingSeconds %= (30 * 24 * 60 * 60);
$days = floor($remainingSeconds / (24 * 60 * 60));

// 7️⃣ نمایش خروجی
echo "⏳ از تاریخ " . $eventDateInput . " تا امروز " . $years . " سال، " . $months . " ماه و " . $days . " روز گذشته است.\n";
?>
```

---

## **📌 توضیح کامل تغییرات و توابع استفاده‌شده**

### **1️⃣ بررسی فرمت تاریخ بدون `preg_match()`**

```php
$parts = explode("-", $eventDateInput);
if (count($parts) != 3 || strlen($parts[0]) != 4 || strlen($parts[1]) != 2 || strlen($parts[2]) != 2) {
    echo "⚠ فرمت تاریخ نامعتبر است. لطفاً تاریخ را به‌صورت YYYY-MM-DD وارد کنید.\n";
    exit;
}
```

🔹 **چرا `explode()`؟**

- `explode("-", $eventDateInput)` رشته را به ۳ بخش تقسیم می‌کند (`YYYY-MM-DD`).
- اگر **دقیقا ۳ قسمت نداشته باشد، تاریخ نامعتبر است**.
- بررسی می‌کنیم که **سال ۴ رقمی** و **ماه و روز ۲ رقمی باشند**.

✅ **ورودی‌های معتبر و نامعتبر:**

```
✅ 2000-07-15  → صحیح
❌ 15/07/2000  → نادرست
❌ 2000-7-5    → نادرست
```

---

### **2️⃣ تبدیل تاریخ به `timestamp` (بدون `DateTime`)**

```php
$eventTimestamp = strtotime($eventDateInput);
$todayTimestamp = time();
```

🔹 `strtotime($eventDateInput)` **تاریخ را به `timestamp` (تعداد ثانیه‌ها از 1970-01-01) تبدیل می‌کند.**  
🔹 `time()` **زمان فعلی را به `timestamp` تبدیل می‌کند.**

✅ **مثال خروجی برای `2000-07-15` و امروز `2025-02-27`:**

```
$eventTimestamp = 963504000;
$todayTimestamp = 1740000000;
```

(اعداد ممکن است بسته به زمان اجرا متفاوت باشند.)

---

### **3️⃣ محاسبه تعداد ثانیه‌های اختلاف**

```php
$diffSeconds = abs($todayTimestamp - $eventTimestamp);
```

🔹 **`abs()`** مقدار **مطلق اختلاف** را می‌گیرد تا مهم نباشد که کدام تاریخ بزرگ‌تر است.  
🔹 **فرمول:**

```
اختلاف ثانیه = مقدار مطلق (timestamp امروز - timestamp تاریخ رویداد)
```

✅ **مثال برای `2000-07-15` تا `2025-02-27`:**

```
$diffSeconds = 773000000
```

(این مقدار دقیق ثانیه‌های اختلاف است.)

---

### **4️⃣ تبدیل ثانیه به سال، ماه و روز**

```php
$years = floor($diffSeconds / (365 * 24 * 60 * 60));
$remainingSeconds = $diffSeconds % (365 * 24 * 60 * 60);
$months = floor($remainingSeconds / (30 * 24 * 60 * 60));
$remainingSeconds %= (30 * 24 * 60 * 60);
$days = floor($remainingSeconds / (24 * 60 * 60));
```

🔹 **تقسیم بر `(365 * 24 * 60 * 60)`** → تعداد **سال‌ها** را محاسبه می‌کند.  
🔹 **باقی‌مانده را با `%` محاسبه می‌کنیم** و سپس تعداد **ماه‌ها** را حساب می‌کنیم.  
🔹 **باقی‌مانده‌ی ماه‌ها را نگه می‌داریم** و آن را به تعداد **روزها** تبدیل می‌کنیم.

✅ **مثال محاسباتی برای `2000-07-15` تا `2025-02-27`:**

```
سال‌ها = 24
ماه‌ها = 7
روزها = 12
```

---

### **5️⃣ نمایش خروجی**

```php
echo "⏳ از تاریخ " . $eventDateInput . " تا امروز " . $years . " سال، " . $months . " ماه و " . $days . " روز گذشته است.\n";
```

✅ **خروجی نهایی برای ورودی `2000-07-15`:**

```
⏳ از تاریخ 2000-07-15 تا امروز 24 سال، 7 ماه و 12 روز گذشته است.
```

---

## **📌 مقایسه دو روش (`DateTime` و `strtotime()`)**

|روش|مزایا|معایب|
|---|---|---|
|**`DateTime` (`->diff()`)**|ساده‌تر، خواناتر، دقیق‌تر|نیاز به `->` (شیءگرایی) دارد|
|**`strtotime()` و `time()`**|سریع‌تر، بدون `->`، بدون `DateTime`|دقت کمتری دارد (ماه‌ها را همیشه ۳۰ روز در نظر می‌گیرد)|

✅ **اگر دقت بالا و ماه‌های واقعی لازم است، `DateTime` بهتر است.**  
✅ **اگر نیاز به عملکرد سریع و بدون `->` باشد، `strtotime()` بهتر است.**

---

## **📌 خلاصه و نتیجه‌گیری**

1️⃣ **کد بازنویسی شد تا `->` و `preg_match()` نداشته باشد.**  
2️⃣ **از `explode()` برای بررسی فرمت تاریخ استفاده شد.**  
3️⃣ **از `strtotime()` و `time()` برای تبدیل تاریخ‌ها به `timestamp` استفاده شد.**  
4️⃣ **اختلاف بر حسب ثانیه محاسبه و سپس به سال، ماه و روز تبدیل شد.**

✅ **این روش ساده‌تر و سریع‌تر است اما در دقت ماه‌ها کمی تفاوت دارد.**  
✅ **اگر بخواهی بدون `->` کار کنی، این روش ایده‌آل است!** 🚀🔥

💬 **اگر سوالی داشتی، بپرس!**

